# 构造函数、原型与原型链

<!-- TOC -->

- [构造函数、原型与原型链](#构造函数原型与原型链)
    - [构造函数](#构造函数)
    - [原型](#原型)
    - [原型链](#原型链)

<!-- /TOC -->

## 构造函数

ECMAScript 中提供了构造函数来创建新对象。但构造函数本身就是一个函数，与普通函数没有任何区别，只不过为了区分，一般将其首字母大写，但这并不是必须的。

**函数被 new 关键字调用时就是构造函数。**

```js
function f(name) {
    console.log("execute");
    this.name = name;
}

var k = new f("k"); // execute
console.log(k); // {name: "k"}
var h = f("h"); // execute
console.log(h); // undefined
```

从上面代码可以看出：

* 首字母是否大写并不影响函数 f 作为构造函数使用，
* 不使用 new 调用函数就是普通函数，直接执行内部代码，使用 new，函数的角色就成为了构造函数，创建一个对象并返回。

## 原型

> 每一个函数都有一个原型对象。

```js
function Foo(){}

Foo.prototype; // {constructor,__proto__}
```

本人的猜想（并不一定正确）：编译器在解析函数时会自动生成一个原型对象，并将该函数的 prototype 属性指向这个对象。

那么这个“自动生成的”原型对象是什么呢？

经过观察，我发现函数的 prototype 属性如何无特殊指定，它指向的原型结构为：

```js
{
    constructor: Foo(){};
    __proto__: Object.prototype;
}
```

其中 constructor 指向当前构造函数；`__proto__` 指向 Object.prototype。

```js
Foo.prototype.constructor === Foo; //  true
Foo.prototype.__proto__ === Object.prototype; // true
```

**原来函数的原型的原型竟然是 Object 的原型！！！！**


## 原型链

对象由构造函数通过 new 关键字创造，那么是如何创造的呢？

new 关键字的内部实现机制：

```js
var obj = {}; // 创建一个空对象
obj.__proto__ = constructor.prototype; // 添加__proto__属性，并指向构造函数的 prototype 属性。
constructor.call(this); // 绑定this
```

构造函数的这个机制说明一切对象都会有一个 __proto__ 属性，这个对象指向构造函数的 prototype。

```js
function Foo(){}

var foo = new Foo();

foo.__proto__ === Foo.prototype; //true
Foo.prototype.__proto__ === Object.prototype; //true
Object.prototype.__proto__ === null; // true
```

代码中：foo 有一个 __proto__ 属性指向 Foo.prototype; Foo.prototype 又有一个 __proto__ 属性指向Object.prototype；而 Object.prototype  又有一个 __proto__ 指针指向 null。像这样，一环抠一环，最终形成了所谓的**原型链**。

**原型的终点是 null**，因为null没有 __proto__ 属性。

```js
null.__proto__ // Uncaught TypeError: Cannot read property '__proto__' of null
```
哇，感觉这很符合创世纪的故事啊—— “初始，一切且不存在（null）”。

*tips： 其实 null 是基本数据类型，typeof null 返回 object 是 ECMAScript 设计上的一个错误*


<!-- 关于 Function.**proto**===Function.prototype 的问题,
是不是可以说 Function 也是 Function 本身的一个实例呢？这个具体该怎么理解 js 这种设计理念呢，Function 是不是既充当鸡又充当蛋呢。。。 -->
