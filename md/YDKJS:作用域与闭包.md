# 作用域与闭包

<!-- TOC -->

- [作用域与闭包](#作用域与闭包)
    - [什么是作用域](#什么是作用域)
        - [编译器](#编译器)
        - [理解作用域](#理解作用域)
        - [嵌套的作用域](#嵌套的作用域)
    - [词法作用域](#词法作用域)
        - [词法分析时](#词法分析时)
        - [欺骗词法作用域](#欺骗词法作用域)

<!-- /TOC -->

## 什么是作用域

> 作用域是一组定义在何处储存变量以及如何访问变量的**规则**。

### 编译器

javascript 是编译型语言。但是与传统编译型语言不同，它是边编译边执行的。编译型语言一般从源码到执行会经历三个步骤：

* 分词／词法分析

  将一连串字符串打断成有意义的片段，成为 token（记号）。

* 解析

  将一个 token 流（数组）转化为一个嵌套元素的树，即抽象语法树（AST）。

* 代码生成

  将抽象语法树转化为可执行的代码。其实是转化成机器指令。

比如`var a = 1`的编译过程：

1. 分词／词法分析： `var a = 1`这段程序可能会被打断成如下 token：`var`、`a`、`=`、`1`，空格保留与否得看其是否具有意义。
2. 解析：将第一步的 token 形成抽象树：大致如下：
   ```
   变量声明: {
       标识符: a
       赋值表达式: {
           数字字面量: 1
       }
   }
   ```
3. 代码生成： 转化成机器命令：创建一个称为 a 的变量，并分配内存，存入一个值为数字 1。

### 理解作用域

> 作用域就是通过标识符名称查询变量的一组规则。

代码解析运行中的角色：

* 引擎

  负责代码的编译和程序的执行。

* 编译器

  协助引擎，主要负责解析和代码生成。

* 作用域

  协助引擎，收集并维护一张所有被声明的标识符（变量）的列表，并对当前执行的代码如何访问这些变量强制实施一组严格的规则。

比如`var a = 1`的运行：

1. 编译器遇到`var a`，会首先让作用域去查询 a 是否已经存在，存在则忽略，不存在，则让作用域创建它；
2. 编译器遇到`a = 1`，会编译成引擎稍后需要运行的代码；
3. 引擎执行编译后的代码，会让当前查看是否存在变量`a`可以访问，存在则引用这个变量，不存在则查看其他其他。

上面过程中，引擎会对变量进行查询，而查询分为 RHS（right-hand Side）查询 和 LHS（left-hand Side）查询，它们根据变量出现在赋值操作的左手边还是右手边来判断查询方式。

* RHS

  变量在赋值的右手边时采用这种方式查询，查不到会抛出错误 `referenceError`

* LHS

  变量在赋值的左手边时采用这种方式查询，在非严格模式下，查不到会再顶层作用域创建这个变量

### 嵌套的作用域

实际工作中，通常会有多于一个的作用域需要考虑，会存在作用域嵌套在其他作用域中的情况。

嵌套作用域的规则：

**从当前作用域开始查找，如果没有，则向上走一级继续查找，以此类推，直至到了最外层全局作用域，无论找到与否，都会停止。**

## 词法作用域

作用域的工作方式一般有俩种模型：词法作用域和动态作用域。javascript 所采用的是词法作用域。

### 词法分析时

> 词法作用域是在词法分析时被定义的作用域。

上述定义的潜在含义即：词法作用域是基于写程序时变量和作用域的块儿在何处被编写所决定的。公认的最佳实践是将词法作用域看作是仅仅依靠词法的。

查询变量：

**引擎查找标识符时会在当前作用域开始一直向最外层作用域查找，一旦匹配到第一个，作用域查询便停止。**

相同名称的标识符可以在嵌套作用域的多个层中被指定，这成为“遮蔽”。

不管函数是从哪里被调用、如何调用，它的词法作用域是由这个函数被声明的位置**唯一**定义的。

### 欺骗词法作用域

javascript 提供了在运行时修改词法作用域的机制——with 和 eval，它们会欺骗词法作用域。实际工作中，这种做法并不被推荐，应当尽量避免使用。

**欺骗词法作用域会导致更低下的性能。**

引擎在编译阶段会对代码做许多优化工作，比如静态地分析代码。但如果代码存在eval和with，导致词法作用域的不固定行为，这一切的优化都有可能毫无意义，所以引擎就会简单地不做任何优化。

1. eval

`eval函数`接收一个字符串作为参数，并在运行时将该字符串的内容在当前位置运行。

```js
function foo(str, a) {
    eval(str); // 作弊！
    console.log(a, b);
}

var b = 2;
foo("var b = 3", 1); //1,3
```

上面的代码，`var b = 3`会再 eval 位置运行，从而在 foo 作用域内创建了变量`b`。当`console.log(a,b)`调用发生时，引擎会直接访问 foo 作用域内的`b`，而不会再访问外部的`b`变量。

**注意：使用严格模式，在 eval 中作出的声明不会实际上修改包围他的作用域**

2. with

我们通常使用 with 来引用一个对象的多个属性。

```js
var obj = {
    a: 1,
    b: 2,
    c: 3
};

with (obj) {
    a = 3;
    b = 4;
    c = 5;
}

console.log(obj); //{a: 3, b: 4, c: 5}
```

但是，with会做的事，比这要多得多。

```js
var o1 = { a: 3 };
var o2 = { b: 3 };

function foo(obj) {
    with (obj) {
        a = 2;
    }
}

foo(o1);
console.log(o1.a); //2

foo(o2);
console.log(o2.a); // undefined
console.log(a); // 2  全局作用域泄漏
```


with语句接受一个对象，并将这个对象视为一个**完全隔离的词法作用域**。

**但是** with块内部的一个普通的`var`声明并不会归于这个`with`块儿的作用域，而是归于包含它的函数作用域。

所以，上面代码执行`foo(o2)`时，在执行到 `a = 2` 时，引擎会进行 `LHS查找`，但是一直到最外层都没有找到a变量，所以会在最外层创建这个变量，这里就造成了作用域泄漏。