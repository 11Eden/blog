# JavaScript事件循环(Event Loop)机制

## 单线程

## JavaScript 是单线程单并发语言

1. 什么是单线程

    主程序只有一个线程，即同一时间片断内其只能执行单个任务。

2. 为什么选择单线程？

    JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。

3. 单线程意味着什么？

    单线程就意味着，所有任务都需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就需要一直等着。这就会导致`IO操作（耗时但cpu闲置）`时造成性能浪费的问题。

4. 如何解决单线程带来的性能问题？

    答案是**异步**！主线程完全可以不管IO操作，暂时挂起处于等待中的任务，先运行排在后面的任务。等到IO操作返回了结果，再回过头，把挂起的任务继续执行下去。于是，所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）

## 异步任务

JavaScript触发异步任务三种行为以及时机：

|  触发行为            |  任务被添加到任务队列的时机     |
|----                 |:----                       |
| DOM操作             | 在用户点击等操作事件完成后      |
| 网络操作（Ajax等）    | 在网络操作响应后              |
| 定时器               | 在规定时间到达后              |


**注：**  当主线程阻塞时，任务队列仍然是能够被推入任务的


## 事件循环（Event Loop）


讲事件循环之前，先了解下网上看到的 JavaScript 内存模型，相信看完这个会对事件循环机制有一种豁然开朗的感觉。

![]




为什么叫事件循环？是因为它是一个循环：

+ 所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。
+ 主线程之外，还存在一个"任务队列"（task queue）。只要异步任务有了运行结果，就在"任务队列"之中放置一个事件。
+ 一旦"执行栈"中的所有同步任务执行完毕，系统就会读取"任务队列"，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。
+ 主线程不断循环执行上面的第三步。

事件循环机制图解：

![](https://raw.githubusercontent.com/bigdots/blog/master/images/201709/eventLoop.png)

这就需要主线程拥有一个函数调用栈以及一个任务队列


根据事件循环（Event Loop）机制来从任务队列中提取出待执行的回调并执行

在主线程中，根据任务队列依次执行任务，
在当前任务中，根据函数函数调用栈，依次执行代码


主线程会依次执行代码，当遇到函数时，会先将函数入栈，函数运行完毕后再将该函数出栈，直到所有代码执行完毕。当函数调用栈为空时，运行时即会根据事件循环（Event Loop）机制来从任务队列中提取出待执行的回调并执行，执行的过程同样会进行函数帧的入栈出栈操作。


回调的事件会将其相关的任务压入到任务队列中

+ 浏览器内核会在其它线程中执行异步操作，当操作完成后，将操作结果以及事先定义的回调函数放入 JavaScript 主线程的任务队列中。
+ JavaScript 主线程会在执行栈清空后，读取任务队列，读取到任务队列中的函数后，将该函数入栈，一直运行直到执行栈清空，再次去读取任务队列，不断循环。
+ 当主线程阻塞时，任务队列仍然是能够被推入任务的。这也就是为什么当页面的 JavaScript 进程阻塞时，我们触发的点击等事件，会在进程恢复后依次执行。

JavaScript 的主线程在遇到异步调用时，这些异步调用会立刻返回某个值，从而让主线程不会在此处阻塞。而真正的异步操作会由浏览器执行，主线程则会在清空当前调用栈后，按照先入先出的顺序读取任务队列里面的任务。

JavaScript 内存模型：




## 任务

1. MacroTask，即Task
    setTimeout, setInterval, setImmediate, requestAnimationFrame, I/O, UI rendering 

2. MicroTask，即Job
     process.nextTick, Promise, Object.observe, MutationObserver 

规则：
> 一个事件循环(Event Loop)会有一个或多个 MacroTask Queue，而仅有一个 MicroTask Queue。每个 MacroTask Queue 都保证自己按照回调入队的顺序依次执行，所以浏览器可以从内部到JS/DOM，保证动作按序发生。当前任务中所生成的 MicroTask ，都会添加到 MicroTask Queue， 并在当前任务执行完毕后，立即执行，在 MacroTask 或者 MicroTask 中产生的 MicroTask 同样会被压入到 MicroTask 队列中并执行。

```js

function ELoop() {
    // 当前任务
    let p = new Promise((resolve, reject)=>{
        console.log("current Task")
        resolve();
    });
    let nextP; 

    setTimeout(()=>{
        console.log("MacroTask_1");
        nextP.then(()=>{
            // 第一次执行时，这段代码并没有执行到。
            console.log("MicroTask_promise_1"); //第一个MicroTask
        })
        console.log("MacroTask_1 end")
    }, 0) // 第一个 MacroTask

    setTimeout(()=>{
        console.log("MacroTask_2");
        console.log("MacroTask_2 end")
    }, 0)// 第二个MacroTask

    nextP = p.then(()=>{
        console.log("MicroTask_promise_2"); //第一个MicroTask
        console.log(1)
    }).then(()=>{
        console.log("MicroTask_promise_3"); // 第二个MicroTask
        console.log(1)
    })

    console.log("current Task end")
}

ELoop();

/**输出结果：
current Task
MicroTask_promise_2
MicroTask_promise_3
MacroTask_1
MicroTask_promise_1
MacroTask_2
**/
```


异步操作：

+ DOM

+ 网络

+ 定时器


## 为什么要异步
单线程，
IO操作慢，但cpu空闲

## Event Loop
主线程从"任务队列"中读取事件，这个过程是循环不断的，
所以整个的这种运行机制又称为Event Loop（事件循环）。